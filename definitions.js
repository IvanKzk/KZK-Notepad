definitions=
[
	["программа ( program )","согласованная (well-formed) по правилам синтаксиса (syntax) строка из алфавита языка программирования",""],
	["язык программирования ( programming language )","формальная знаковая система для планирования поведения компьютера",""],
	["формальный язык","множество конечных строк над конечным алфавитом",""],
	["семантика","правила, задающие связть между синтаксическими элементами и их значениями",""],
	["пргаматика","языковые средства установления контекста, ролей и передачи целевых установок между людьми",""],
	["предварительная обработка","преобразование набора символов в набор токенов",""],
	["объект ( object )","область памяти среды выполнения, являющаяся представлением некоторого значения",""],
	["значение ( value )","точный смысл содержимого объекта, трактуемый исходя из его типа",""],
	["выражение ( epression )","последовательность операций и операндов",""],
	["подвыражение ( sub-expression )","выражения, которые являются частью других выражений",""],
	["полное выражение ( full expression )","выражения, которые не являются частью других выражений",""],
	["операнд ( operand )","входные данные операций в виде значений",""],
	["арность ( arity )","число операндов операции","1 - унарные, 2 - бинарные, 3 - тернарные"],
	["операция","токен, обозначающий отдельное вычисление",""],
	["унарная операция","операция с арностью 1",""],
	["бинарная операция","операция с арностью 2",""],
	["тернарная операция","операция с арностью 3",""],
	["результат выражения","значение определенного типа",""],
	["побочный эффект ( side effect )","\"все, кроме вычисленного результата\" - изменение состояния среды выполнения",""],
	["вычисление выражения ( evaluation )","процесс вычисления значения выражения и инициализации всех входящих в него побочных эффектов",""],
	["входные параметры функции (процедуры)","объекты, принимающие значения, называемые аргументами",""],
	["оператор ( statement )","задает выполняемые программой действия",""],
	["описание ( declaration )","вводит в программу имена и соответствующие им сущности",""],
	["определение ( definition )","описание, которое помимо свойств сущности задает ее содержимое","программа должна содержать не более одного определения каждой сущности и в точности одно для каждой используемой (ODR - One Definition Rule)"],
	["приведение типов ( type cast )","изменение типа значения с максимально возможным сохранением смысла","Из плавающей точки в целочисленный - дробная часть отбрасывается, UB если не представимо.\nИз целочисленного в плавающую точку - если возможно в точности, иначе выбор одного из ближайших (какое конкретно зависит от реализации)\n\n\n(лекция 19.09)\n"],
	["явное ( explicit )","приведение типов по запросу программиста (операциями)","(лекция 19.09)"],
	["неявное ( implicit )","приведение типов автоматически, по факту несовпадения требуемого и имеющегося типа","(лекция 19.09)"],
	["стандартное ( standart )","приведение типов, втроенное в язык","(лекция 19.09)"],
	["integral promotion","для rank(T)<rank(int) преобразовние в int, если все значения исходного типа представимы в int, иначе к unsigned (влезет точно)","(лекция 19.09)"],
	["integral conversion","прочие (не integral promotion) преобразования между целочисленными типами. Результат - единственное значение целевого типа, соответствующее исходному значению 2^W","(лекция 19.09)"],
	["floating-point promotion","приведение типа float к double","(лекция 19.09)"],
	["floating-point conversion","приведение типа double к типу float. Если влезает в точности - оставляем, если нет, значит мы находимся между двумя представимыми значениями - выбор одного из них (какое конкретно - зависит от реализации)","(лекция 19.09)"],
	["boolean-conversion","приведение типа к типу bool - 0=false, не 0=false","(лекция 19.09)"],
	["арифметические операции","Унарные: сохранение знака (+), смена знака (-)Бинарные: сложение (+), вычитание (-), умножение (*), деление (/), остаток от деления (%)\n\ni++ - постфиксная\n++i - префиксная\nПорядок преобразования типов, используемых в бинарных операциях / обычные арифметические преобразования:\n    1) Если есть операнд(ы) с плавающей точкой выбираем его (большей ширины)\n    2) Иначе integral promotion. Если типы стали одинаковыми - это результат\n    ...\n    ...\n    (Лекция 19.09 2:17:46)\nБинарные логические операции вычисляются по короткой схеме - сначала вычисляется левый операнд, и второй не вычисляется если не нужно\n","(лекция 19.09)"],
	["базовые характеристики описываемых сущностей","последовательность спецификаторов описания (declaration specifier) в любом порядке, включая спецификатор типа (type specifier)","       int x,y\n         |\n(спецификатор типа)\n\n(лекция 26.09)\n"],
	["описатель ( declarator )","имена сущностей и конструкции создания производных типов, применяемые к ним относительно типа, заданного спецификатором типа описания","       int x,y\n             |\n   (описатель)\n\n(лекция 26.09)\n"],
	["категория значения","одна из характеристик любого выражения помимо типа","(лекция 26.09)"],
	["glvalue ( обобщенное леводопустимое )","категория значения, которая идентифицирует объект или функцию. Результат (result) такого выражения - идентифицируемая сущность","(лекция 26.09)"],
	["prvalue ( чисто праводопустимое )","категория значения, предназначенная для задания начальных значений объектов или для использования в качестве операндов выражений. Результирующий объект (result object) такого выражения - тот, начальное значение которого им задается. Если используется как операнд, то его нет.","(лекция 26.09)"],
	["модифицируемый объект","объект, для которого разрешена и запись и чтение","(лекция 26.09)"],
	["lvalue-to-rvalue conversion","чтение при использовании glvalue в контексте, где требуется prvalue. Запись: операция простого присваивания =. Левый операнд должен быть модифицируемым lvalue. Правый - prvalue. Значение справа приводится к типу операнда слева. Побочный эффект - запись правого значения в объект, идентифицируемый левым. Результат - левый операнд.","(лекция 26.09)"],
	["оператор-выражения ( expression statement )","предписывает вычислить выражение, в нем содержащееся, и отбросить результат. Имеет синтаксис выражения и ; в конце","a=0; - оператор выражения\nc=a+b; - оператор выражения\n\n\n(лекция 26.09)"],
	["составной оператор ( block )","соответствует последовательности структурного программирования. Синтаксически это пара фигурных скобок (открывающая и закрывающая), между которыми можно записать сколько угодно других операторов. Предписывает содержащиеся в нем операторы выполнить по порядку их записи","{\n    double z;\n    {\n        z = 1;\n        z = 2;\n    }\n    z = 3;\n}\n\n\n(лекция 26.09)"],
	["характеристики сущностей описания","область видимости (scope), связанность (linkage), время хранения (storage duration) ","(лекция 26.09)"],
	["область видимости ( scope )","та часть текста программы, где данное имя может использоваться для идентификации этой сущности","Блочная область видимости (block) - описание ограничено тем блоком, в котором дано \n\n\n(лекция 26.09)\n"],
	["время хранения ( storage duration )","характеристика объекта, которая определяет в какой момент для него выделяется память, а в какой освобождается","Для обычного описания в блоке - автоматическое (automatic)\n\n\n(лекция 26.09)\n"],
	["инициализация","задание начального значения объекта","(лекция 26.09)"],
	["инициализация копированием ( copy initialization )","инициализация в определении с помощью инициализатора (initializer)","(лекция 26.09)"],
	["инициализация по умолчанию ( default initialization )","производится, если инициализатор не указан. Для фундаментальных типов не делает ничего","(лекция 26.09)"],
	["операции составного присваивания","","++x, x++, x+=1, x*=2, x/=3 и тд\n\n\n(лекция 26.09)\n"],
	["функция","производный тип.\n\n\n      задание производного типа\n                     |\ndouble func(double var1, double var2) {\n    ...\n    ...\n}\n        операция вызова функции\n                               |\ndouble var3=func(var1, var2)","(лекция 26.09)"],
	["единица трансляции","последовательность описаний в глобальном пространстве имен","(лекция 26.09)"],
	["пространства имен","вводятся с помощью определений пространства имен. Синтаксически - ключевое слов namespace, имя пространства (идентификатор), последовательность описаний в фигурных скобках","namespace A \n{\n    int f()\n        {\n            return 1\n        }\n}\n\n\nnamespace B \n{\n    int f()\n        {\n            return A::f();\n        }\n}\n\n\nРазница в записях A::f() и ::A::f() : в первом случае поиск идет начиная с места, где находится A и расширяется, а во втором случае сразу во всем глобальном пространстве имен\n\n\nВложенные пространства можно записывать namespace A::B\n\n\nПространства имен можно доопределять: \n\n    namespace  A { namespace B {int f() {return 1;}}}\n    namespace A::B {int g() {return 2;}}\n\n    При обращении к namespace A::B поиск будет происходить в обоих заданных местах\n\n(лекция 26.09)"],
	["условная тернарная операция","op1 ? op2 : op3\n\n\nОперация, которая вычисляет только либо op2, либо op3, в зависимости от op1","(лекция 03.10)"],
	["директива препроцессора ( preprocessing directive )","строка, первый непробельный символ которых - #\n\n\nОбщий синтаксис: # имя_директивы аргументы...\n\n\n#include <имя-заголовочного-файла> - текстовое включение указанного заголовочного файла, поиск которого осуществляется в последовательности каталогов поиска заголовочных файлов","(лекция 03.10)"],
	["заголовочный файл ( header file )","файл с описанием интерфейса единицы трансляции, защищенный от повторного включения","(лекция 03.10)"],
	["форматированный вывод","включить заголовок <iostream> для получения описания std::cout\n\n\nПобочный эффект от применения бинарной инфиксной операции << к std::cout и арифметическим типам/строковым литералам - вывод их представления в стандартный файл (поток/stream) вывода. Результат - левый операнд (ассоциативность слева направо)\n\n\nТо же для std::cerr для стандартного файла вывода ошибок \n\n\nBool выводится как 0/1, узкие символьные типы как символы с соответствующими кодами\n\n\nПри работе с терминалом буферизация построчно","(лекция 03.10)"],
	["тип void","тип с пустым множеством значений\n\n\nТип void - неполный (incomplete) - размер его представления в памяти формально не известен, поэтому объекты типа void создать нельзя (но можно иметь результаты такого типа в выражениях)\n\n\nЛюбое значение может быть приведено к типу void, чтобы отбросить его, других операций с его участием нет \n\n\nПрименяется в качестве типа возвращаемого значения для функций, которым нечего по смыслу возвращать (т. е. которые вызываются ради побочных эффектов). (В таких функциях разрешается оператор return без выражения и возврат за счет явного достижения конца тела без явного return) ","void line() {\n    std::cout << \"------------------\\n\";\n    //return\n}\n\n(лекция 03.10)"],
	["форматированный ввод","аналогично выводу, для std::cin, операции >> и леводопустимого правого операнда\n\n\n1. Проверить флаг ошибки. Если стоит - ничего не делать\n2. Пропустить все пробельные символы\n3. Вводить символы, пока накопленные есть корректное представление требуемого типа, аналогичное литералам, кроме:\n    - нет префиксов систем счисления (всегда основание 10) и суффиксов ширин/знаковости\n    - целочисленные по форме литералы подходят и плавающей точке\n    - допускается знак величины перед ней\n    - булевские значения ожидают 0/1\n    - узкие символьные типы вводят один символ как его код\n    Первый неподходящий символ остается не считанным\n4. Производится попытка преобразовать последовательность считанных символов в значения требуемого типа\n    - удалось (в рамках значений типа) - побочный эффект: запись вправо операнд этого значения\n    - не удалось: выставление флага ошибки на потоке. Побочный эффект - запись в объект минимального/максимального представимого значения, если неудача из-за непредставимости, или ноль, если преобразуемая последовательность была пустой/некорректной.\n\n\n- std::cin контекстно преобразуем (is contextly convertible) к bool со значением отсутствия флага ошибки\n","(лекция 03.10)"],
	["операция \"запятая\"","вычисляет оба операнда по порядку, результат – второй","while(std::cout << \"Input a number: \", std::cin>>x) std::cout << x << \"^2 = \" << x*x << '\\n'\n\n(лекция 03.10)"],
	["оператор for","запись for ( expr1; expr2; expr3 ) statement эквивалентна записи \n{\n    expr1;\n    while(expr2) {\n        statement;\n        expr3;\n    }\n}","(лекция 03.10)"],
	["операторы перехода","","int i;\nfor (i=0; i<100; ++i) {\n    if (bad(i)) \n        break; //goto after_loop;\n    if (slightly_bad(i))\n        continue; //goto end_of_iteration;\n    end_of_iteration: ;\n}\nafter_loop: ;\n\n(лекция 03.10)"],
	["перегрузка функций ","в одной области видимости допускаются не связанные описания одноименных функций, различающихся по набору входных параметров – перегрузка функций (function overloading)\n\nВыбор из этого множества перегрузок (overloading set) дополнительный шаг алгоритма поиска имён\n\nВыбор осуществляется исходя из типов аргументов, выясняемых в контексте использования имени функции, в нашем случае – операции вызова функции","(лекция 10.10)"],
	["разрешение перегрузок","(overload resolution) \n\n1. Оставить в множестве перегрузок только годные (viable) функции: совпадающие по числу параметров с числом аргументов так, что из каждого типа аргумента есть неявное преобразование в тип соответствующего параметра\n2. Если годных не осталось – семантическая ошибка. Если годная одна - это результат\n3. Иначе годных больше одной и требуется выяснение наилучшей годной (best viable).\n Наилучшая годная та, которая лучше всех остальных (если такая есть, то она только одна по построению).\n Чтобы быть лучше другой функции, данная должна быть лучше по хотя бы одному параметру, и не хуже по всем остальным.\n Для конкретного типа аргумента и двух соответствующих параметров функции требуемые преобразования классифицируются по рангам в порядке ухудшения:\n - Точное совпадение (exact match) - преобразований типа не требуется.\n - Повышения (promotions) - integer/floating promotion.\n - Преобразования (conversions) - всё остальное из рассмотренного нами.","(лекция 10.10)"],
	["псевдонимы типов","описание (не стандартной формы), вводящее в программе имя (задаваемая идентификатором), которое далее может использоваться в качестве другого имени указанного типа, в том числе спецификаторах типа. Позволяет сокращать сложные имена типов, особенно полезно для типов с большим набором конструкций создания производных типов","using ull = unsigned long long;\null x = 1000000000000000000;\n\n(лекция 10.10)"],
	["типы фиксированной ширины","псевдонимы типов, описанные в <cstdint>\n- общая схема именования: 8\n (без префикса) (ничего) 16\n u int _fast 32 _t\n _least 64\n1) Префикс: u - беззнаковый, без него - знаковый\n2) Точность соответствия\n - без указания: в точности указанное число бит, без битов заполнения. Могут отсутствовать, если не поддерживаются архитектурой.\n - least - минимум указанное число бит, больше если данное в точности архитектурой не поддерживается\n - fast - минимум указанное число бит, максимальная скорость (обычно отражает отсутствие целочисленных повышений)","std::uint16_t - беззнаковый тип шириной 16 бит (если есть)\n\n(лекция 10.10)"],
	["квалификатор const","относится к т.н. cv-квалификаторам\n- является спецификатором типа, дополняющим и требующим другой спецификатор типа (не самодостаточен)\n- делает соответствующий объект не изменяемым\n - характеристика сохраняется у леводопустимых выражений, идентифицирующих этот объект, делая его непригодным для использования в левом операнде присваивания и \n других контекстах, осуществляющих запись \n- не модифицируемые объекты не могут иметь неопределённых начальных значений и требуют явной инициализации\n- для большинства типов языка квалификатор отбрасывается как часть преобразования lvalue-to-rvalue, т. к. описывает по смыслу свойства операций над объектом, а не самим значением","const double pi = 3.1415926\n\n(лекция 10.10)"],
	["константные выражения","( constant expressions ) выражения, которые могут быть вычислены на этапе трансляции\n\nСемантически - выражения ограниченной задаваемыми компилятором лимитами сложности, в процессе вычисления которых не происходит (из известного нам):\n- доступа к объектам\n- вызова функций\n- неопределенного поведения\n\nЧтобы объект можно было прочесть в константном выражении он должен быть описан со спецификатором описания constexpr: это подразумевает const (неизменяемость) и требует константное выражение в качестве инициализатора: constexpr double pi = 3.1415926 //std::acos(-1) не годится - вызов функции\n\nЧтобы функцию тоже можно было вызвать в константном выражение, её тоже можно описать со спецификатором описания constexpr с ограничениями:\n- типы возвращаемого значения и параметров - литеральные\n- нет goto (оператор перехода) и меток для него\n- определения только инициализированных детерминированными значениями объектов с автоматическим временем хранения\n\nЕсли при вычислении constexpr функции какие-то требования не выполнены, она вычисляется как обычно, только результат не считается константным выражением\n\nРазрешен доступ к объектам, созданных в процессе вычисления","constexpr следует предпочитать const по возможности\n - неизменяемые значения целочисленных типов также читаемы из константных выражений\n\n(лекция 10.10)"],
	["оператор switch","Вычисляет выражение целочисленного типа (с повышением)\n\n- Переходит на метку case в statement со значением, равным значению выражения\n\n- Если такой нет, переходит на метку default\n\n- Если такого тоже нет, ничего не делает\n\n- Выражения в метках case - константные \n\n- break выходит из тела switch","switch(month) {\n case 2: return \"February\";\n case 4: return \"April\";\n case 12: return \"December\";\n}\n\nОдна из самых каверзных вещей в switch — это последовательность выполнения кода. Когда кейс совпал (или выполняется default), то выполнение начинается с первого стейтмента, который находится после соответствующего кейса и продолжается до тех пор, пока не будет выполнено одно из следующих условий завершения:\n\n - Достигнут конец блока switch.\n\n - Выполняется оператор return.\n\n - Выполняется оператор goto.\n\n - Выполняется оператор break.\n\n\nswitch (2)\n{\n case 1: // Не совпадает!\n std::cout << 1 << '\\n'; // пропускается\n case 2: // Совпало!\n std::cout << 2 << '\\n'; // выполнение кода начинается здесь\n case 3:\n std::cout << 3 << '\\n'; // это также выполнится\n case 4:\n std::cout << 4 << '\\n'; // и это\n default:\n std::cout << 5 << '\\n'; // и это\n}\n\n(лекция 10.10)"],
	["статическое время хранения","определения объектов в области видимости пространства имен или со спецификатором времени хранения (описания) static в области видимости блока имеют статическое (static) время хранения\n\nУничтожение происходит в процессе вызова std::exit явно или в результате выхода из main\n\nПамять под объекты со статическим временем хранения выделяется транслятором в объектном файле\n\nИнициализация объектов со статическим временем хранения включает две фазы:\n- Статическая: сохранение некоторого значения, вычисленного транслятором, в объектный файл: если инициализатор константен, то его значение, иначе выполняется инициализация нулем (zero initialization): заполнение представления объекта байтами с нулевыми битами\n\n- Динамическая: если требуется, до вызова main выполняется код, соответствующий вычислению не константного инициализатора. Такие инициализаторы вычисляются по порядку следования объектов в единице трансляции, но порядок инициализации объектов в разных единицах трансляции не уточняется. Для определений в блоках происходит при первом выполнении определения\n \nТранслятор волен заменить динамическую фазу статической, если возможно (оптимизация)","(лекция 10.10)"],
	["связанность ( linkage )","характеристика, необходимая в ситуации, когда одной сущности соответствует несколько описаний\n\nДля простого блока в описании отсутствует. (значит это первое и последнее описание данной сущности в программе, значит это определение)\n\n\n(лекция 26.09)\n\n\n-характеристика имени в описании, определяющая возможность соответствия описываемой сущности таковым в других описаниях с тем же полностью квалифицированным именем\n\n- Когда связанность отсутствует, соответствующее описание говорит о новой сущности в первый и последний раз (и является определением)\n- Внутренняя связанность позволяет нескольким описаниям в одной единице трансляции говорить об одной сущности\n- Внешняя связанность позволяет то же в пределах всей программы. Она реализуется компоновщиком\n- Если сущность обладает типом, он должен быть совместимым между описаниями (отличаться только по форме/полноте записи)\n\nУ сущностей, имеющих полностью квалифицированные имена связанность по умолчанию внешняя: \n- пространства имен (включая глобальное)\n- функции (можно описать как extern явно)\n- описания объектов в пространствах имен (за исключением неизменяемых объектов в пространствах имен - они имеют внешнюю связанность только со спецификатором времени хранения extern)\n\nВнутреннюю связанность имеют:\n - неизменяемые объекты в пространствах имён по умолчанию\n - объекты в пространствах имён, и функции описанные первый раз со спецификатором времени хранения static\n - анонимные пространства имён и всё описанное в них на любую глубину\n\nПо правилу одного определения, все, кроме одного определения должны быть просто описаниями: \n - для функций: отсутствует тело\n - для объектов: спецификатор времени хранения extern без инициализатора\n - пространства имён всегда определения, но новые определения не конфликтуют, а расширяют предыдущие\n","void tick(int n); //без этого рекурсия не будет работать, так как поиск имен осуществляется вверх от точки использования\n\nvoid tock(int n) {\n std::cout << \"TOCK: \" << n << '\\n';\n if(n) tick(n-1);\n}\n\nvoid tick(int n) {\n std::cout << \"TICK: \" << n << '\\n';\n if(n) tock(n-1);\n}\n\n\n//a.cpp\nnamespace my_math {\n extern const int magic = 0x31337;\n}\n\nvoid func(...) {...}\n\n//b.cpp\nnamespace my_math {\n extern const int magic; //из-за extern говорит о той же сущности, что и в a.cpp\n}\nstatic void func(...) {...} //без static была бы ошибка, т. к. у такого объекта связанность по умолчания внешняя (ошибка - два определения - из a.cpp и b.cpp)\n(лекция 17.10)"],
	[" анонимное пространство имен","пространство имен, у которого не указано имя\nУ него есть имя, но программисту оно не известно. Получается в полном квалифицированном имени есть неизвестная компонента, поэтому само пространство имен и все, что в нем содержится, ограничено по связанности внутренней. Это более современный и быстрый способ придания внутренней связанности вместо static на каждом описании. Для доступа к его членам снаружи в той же единице трансляции считается, что описания в нем - члены окружающего пространства имен.","(лекция 17.10)"],
	["спецификатор inline ( встраиваемый )","исторически применяется на функциях, чтобы отметить их для встраивания. Компилятор в каждом месте, где вызывается inline функция, проводит анализ, что будет выгоднее - вызвать ее механизмом вызова функции или скопировать машинный код функции (встроить) в точку вызова (эти два способа могут различаться по затратам ресурсов). Современные трансляторы в режиме оптимизаций встраивают то, что считают выгодным в каждом конкретном случае, независимо от наличия inline (даже между двумя единицами трансляции при использовании LTO). inline сущности должны быть определены в точке использования. Если связанность внешняя, определение должно быть одинаковым во всех единицах трансляции и разрешается, несмотря на ODR (One Definition Rule).","(лекция 17.10)"],
	["макроподстановки ( макросы )","вводятся директивами препроцессора #define\nМакросы-объекты (object-like macro) параметров не имеют и соответствуют одного идентификатора другой последовательностью токенов. Когда какой-то идентификатор становится именем макроса, во всем последующем тексте единицы трансляции, если этот идентификатор встречается, препроцессор его выкидывает, а на его место вставляет последовательность токенов, которая была указана до этого в define.","#define FOREVER for(;;)\nvoid f() { FOREVER { std::cout << '!'; } }\n\n(лекция 17.10)"],
	["макросы - функции","(function-like macro) имеют параметры: именованные последовательности токенов для замены внутри данного. Препроцессор заменяет макрос-функцию на последовательность токенов, где вместо соответствующих параметров включены соответствующие конструкции.","#define MAX(x,y) x>y?x:y\nconstexpr int c1 = MAX(2,3+4); //! - 2>3+4?2:3+4 => false+4?2:3+4 => 4?2:3+4 => ...\n#undef MAX\n#define MAX...\n\n(лекция 17.10)"],
	["условное включение","\n#if выражение\n#else\n#endif\n\nТранслируется одна из двух ветвей. Выражение - константное, вычисляется в типе std::intmax_t/std::uintmax_t. Все идентификаторы, оставшиеся после макроподстановок, заменяются на 0.\n\ndefined(идентификатор) - проверка, является ли макросом.\n - #ifdef идентификатор / #ifndef идентификатор\n\n__has_include <имя_файла> - проверка наличия файла","(лекция 17.10)"],
	["заголовочные файлы","(header file) - файлы с описаниями интерфейсов единиц трансляции. Для c++ используется расширение .hpp (стандартная библиотека - исключение)\n\n- содержат описания сущностей с внешней связанностью, определенных в единице трансляции\n\n- содержат определения в случаях, когда это необходимо: пространства имен, псевдонимы типов, используемые в описаниях, встраиваемые функции и др.\n\n- заголовочные файлы защищены от повторного включения механизмом header guard\n\n- если реализация такой сущности не требуется, тогда заголовочный файл может существовать и без соответствующей единицы трансляции","(лекция 17.10)"],
	["математические константы","в заголовочном файле <numbers> стандартной библиотеки (C++20 и выше) есть определения следующего вида: \n\nnamespace std::numbers\n{\n constexpr inline double pi = /*...*/;\n\n //А также inv_pi,inv_sqrtpi,e,log2e,log10e,\n //ln2,ln10,sqrt2,sqrt3,inv_sqrt3,egamma,phi\n}","(лекция 17.10)"],
	["определения псевдонимов пространств имен","namespace идентификатор = имя_пространства имен","#include <boost/hana.cpp>\nnamespace bh = boost::hana;\n// ... bh::apply(...);\n\n(лекция 17.10)"],
	["описания using","using квалифицированное_имя\n\nЯвляется еще одним описанием (не определением) указанной сущности - позволяет делать доступными сущности из других пространств имен в данной области видимости, что может сократить требуемые имена","using std::cout;\ncout << ... //std:: не требуется\n\n(лекция 17.10)"],
	["директива using","using namespace имя_пространства_имен\n\nДелает описание из указанного пространства имен видимыми при неквалифицированном поиске имен в ближайшем пространстве имен, окружающем текущую область видимости и номинируемое пространство имен. Транзитивна, если в номинируемом пространстве имен тоже есть директивы using. Для квалифицированного поиска объединение номинируемых пространств имен просматривается, если в указанной компоненте следующее имя не найдено. \n\nМожет сократить написание сразу множества имен, но возвращает к проблеме одной глобальной области видимости с конфликтами!","(лекция 17.10)"],
	["побитовые операции","операции & (побитовое И), | (побитовое ИЛИ) и ^ (побитовое исключающее ИЛИ) - бинарные инфиксные операции, применяемые к целочисленным операндам\n\n- после обычных арифметических преобразований применяют соответствующую булеву операцию попарно над битами операндов для формирования результата\n- никакого специального порядка вычислений, как для логических операций, нет\n- операция ~ (побитовое отрицание) - унарная префиксная. Примененная к целочисленному типу инвертирует все его биты после целочисленного повышения\n- реализованы аппаратно на всех процессорах, фактически эффективнее обычных сложений и вычитаний, т. к. не содержат переносов, как в сложении, и полностью параллельны на битовом уровне\n\n\n- операции << (побитовый сдвиг влево) и >> (побитовый сдвиг вправо) - бинарные инфиксные операции, применимые к целочисленным операндам\n\n- вместо обычных арифметических преобразований отдельно повышают оба операнда, тип результата - тип левого после повышения\n- правый операнд должен быть неотрицателен и меньше ширины (повышенного) левого операнда\n- при сдвиге влево заполнение справа нулями, сдвинутые за границу представления влево разряды теряются\n- при сдвиге вправо заполнение слева нулями для беззнакового типа левого операнда и битом знака для знакового, разряды справа теряются\n\nИспользование нами << и >> для ввода и вывода - следствие возможности давать произвольную семантику операциям над пользовательскими типами (типами потоков ввода-вывода в этом случае). Побитовый сдвиг - встроенная в язык семантика этих операций","(лекция 30.10)"],
	["перечисление ( enumeration )","производный тип, множество значений которого состоит из явно заданных поименованных элементов\n\nПеречисление с областью видимости (scoped enumeration) вводится спецификатором типа в формате enum struct имя-типа-перечисления { перечислители... }\n\nУ каждого перечисления есть тип представления (underlying type) - целочисленный тип, определяющий представление перечисления в памяти. Перечислители соответствуют определенным значениям в этом типе.\n\nНижележащий тип по умолчанию - int. Если требуется другой, можно указать через: имя-типа после имени\n\nПеречислителям можно дать конкретные значения через синтаксис, аналогичный инициализации копированием. Для перечислителей без инициализаторов назначается значение на 1 больше предыдущего, или 0 для самого первого.\n\nПеречисления могут быть явно преобразованы в свой тип представления или назад с использованием static_cast\n\nПеречисления без области видимости (unscoped enumerations) вводятся ключом enum вместо enum struct и соответствуют старой конструкции из языка C. Отличия: \n- если не указан нижележащий тип, то он не фиксированный int, а некоторый неуточняемый, в котором представимы все перечислители\n- имена перечислителей видны не только в области видимости перечисления, но и в окружающей области видимости\n- преобразование из типа-перечисления явное и входит в состав integral promotions / conversions","enum struct rainbow_color {\n red,orange,yellow,green,blue,indigo,violet\n};\n\nrainbow_color my_favourite_color = rainbow_color::green;\n\nvoid draw_rainbow_part(rainbow_color pencil_color) {\n if (pencil_color==rainbow_color::red) {\n std::cout << \"I don't like red!\\n\";\n return;\n }\n}\n\n(лекция 30.10)"],
	["перечислители ( enumerators )","список идентификаторов через запятую, задающих имена значений данного типа. Перечисление - именованная область видимости, перечислители могут быть поименованы через квалифицированные имена. В выражениях они являются константными prvalue типа перечисления","(лекция 30.10)"],
	["аргументы по умолчанию","","void line(int n, char c) {\n while(n--)\n std::cout << c;\n}\n\nvoid line(n) {\n line(n, '-');\n}\n\nтоже самое, что:\n\nvoid line(int n, char c = '-') {\n while(n--)\n std::cout << c;\n}\n\nПосле аргумента со значением по умолчанию все остальные тоже должны их иметь (иначе появятся пробелы и будет проблема с соотнесением). Аккумулируются по всем связанным описаниям, повторы запрещены - обычно задаются все на первом описании.\n\n(лекция 13.11)"],
	["леводопустимая ссылка","конструкция создания производных типов, предназначенная для сущностей (\"ссылок\"), идентифицирующих объекты и функции. Обозначается в описателе префиксно &\n\nСсылка - отдельный вид сущностей, занимает ли она память среды выполнения - не уточняется, поэтому временем хранения не обладает. Область видимости определяется как обычно, связанность и описание / определение - как для объектов.\n\nСсылка позволяет дать дополнительное имя объекту или функции\n\nИнициализация ссылки называется привязкой (binding) и необходима. После создания ссылка в выражениях является lvalue, идентифицирующим привязанную к ней сущность. К ссылке можно привязать ссылочно-совместимую (reference-compatible) сущность, пока это означает точное совпадение типа.\n\nС помощью ссылок можно \"обрезать\" возможность взаимодействия с объектом, не нельзя расширять:","int a = 1;\nconst int& ra = a; //можно читать, нельзя изменять\n\n\nconst int a =1;\nint& ra = a; //ошибка - нельзя добавить редактируемость (новое имя переменной (ссылка) не может расширять возможности переменной)\n\n\n#include <cmath>\n#include <iostream>\nvoid print_table(double (&f)(double),double from, double to, double step) { //ссылка на функцию\n for(double x=from;x<=to;x+=step)\n std::cout << f(x) << ' ';\n std::cout << '\\n';\n}\n\nint main() {\n print_table(std::sin,0.,10.,1.);\n print_table(std::cos,0.,1.,0.1);\n}\n\n(лекция 13.11)"],
	["указатель","конструкция создания производного типа на базе (не обязательно полного) типа объекта или функции, соответствующая значению адреса указанной сущности. Обозначается в описателе префиксно *\n\nУказатели - тип данных. Представление в памяти зависит от среды выполнения (номер байта для плоской модели памяти).\n - указатели выводимы в потоки в зависящем от реализации формате\n\nПрефиксная операция взятия адреса & применима к lvalue значениям объектов и функций типа T и возвращает prvalue типа T* со значением их адреса.\n - значения категории \"функция\" имеют неявное преобразование, называемое разложением (decay) в указатель на свой тип\n\nПрефиксная операция разыменования (dereference) применима к prvalue типа T* и возвращает леводопустимое значение типа T, идентифицирующее сущность по адресу, заданному операндом.\n\nУказатели одного типа могут быть сравнены на == или != для проверки, хранят ли адрес одной и той же сущности.","int *p; //указатель на int\nint * const p; //неизменяемый указатель на int\nint const *p; //указатель на неизменяемый int\nconst int *p; //то же\nconst int * const p5; //неизменяемый указатель на неизменяемый int\n\n\nint ** можно в const int * const *, но не const int **\n\n(лекция 13.11)"],
	["висячие ( dangling ) указатели и ссылки ","привязанные к уже не существующему объекту. Разыменование указателя, не идентифицирующего существующий объект или висячей ссылке - undefined behaviour","void f(int* p) {\n *p = 3;\n}\n\nvoid g() {\n int *p;\n {\n int x;\n f(&x);\n p = &x;\n }\n std::cout << *p << '\\n'; //UB\n}\n\n(лекция 13.11)"],
	["нулевой указатель","<cstddef> содержит описание фундаментального типа std::nullptr_t. Это тип константы нулевого указателя (null pointer constant). У этого типа есть единственное значение, собственно, константа нулевого указателя, записываемое литералом указателя nullptr (prvalue).\n - целочисленный литерал со значением 0 или макрос NULL также являются константами нулевого указателя для совместимости с C/C++<11\n\nСуществует неявное преобразование типа указателей (pointer comversion), преобразующее значение типа std::nullptr_t в значение типа T* для любого T, называемое нулевым указателем данного типа. Это специальное значение, показывающее, что указатель не содержит адрес никакого реального объекта.\n\nЛогические преобразования включают преобразование T* в bool - ложь для нулевого указателя, истина иначе (включая висячие!)","(лекция 13.11)"],
	["многоуровневый указатель","указатель строится на базе типа данных или функции, и сам является типом данных, так что можно применить его несколько раз:","int a; //объект целочисленного типа\nint *b = &a; //объект, который хранит адрес объекта целочисленного типа\nint **c = &b; //объект, который хранит адрес объекта, который хранит адрес объекта целочисленного типа\n\n(лекция 13.11)"],
	["подобъект ( subobject )","объект, входящий в представление другого объекта","(лекция 13.11)"],
	["агрегаты ( aggregates )","типы объектов, множество значений которых есть декартово произведение множеств значений всех своих объектов","(лекция 13.11)"],
	["класс","производный тип, полностью определяющий свое представление в памяти и допустимые операции\n\nВводится спецификатором типа, состоящим из ключа класса (struct), опциональным именем, и содержанием внутри фигурных скобок\n - без имени повторное идентичное задание такого же класса является уже другим типом\n - внутри скобок идет произвольная последовательность описаний\n - является областью видимости, может обладать полностью квалифицированным именем, связанностью\n\nПоиск имен в классах осуществляется не только до, но и после точки использования\n\nПредставление в памяти:\n\nstruct S {\n std::uint16_t a;\n std::uint32_t b;\n std::uint8_t c;\n}\n\n//Максимальный из членов\n\nalignof(S) == 4;\n\n//Кратен выравниванию\n\nsizof(S) == 12;\n\n __ __\n| 0| a|\n|__|__|\n| 1| a|\n|__|__|\n| 2| |\n|__|__|\n| 3| |\\\n|__|__| \\\n| 4| b| \\\n|__|__| \\\n| 5| b| \\\n|__|__| \\\n| 6| b| \\\n|__|__| байты заполнения\n| 7| b| /\n|__|__| /\n| 8| c| /\n|__|__| /\n| 9| | /\n|__|__|/\n|10| |\n|__|__|\n|11| |\n|__|__|","(лекция 13.11)"],
	["операция sizeof","унарная префиксная операция, применимая к выражениям или типам в круглых скобках. Возвращает константный размер указанного типа или типа результата выражения (не вычисляемого) в байтах, тип std::size_t","(лекция 13.11)"],
	["операция alignof","(тип) возвращает константное выравнивание (alignment) указанного типа как std::size_t - степень числа 2, которой должен быть численно кратен адрес любого объекта данного типа (для фундаментальных типов обычно совпадает с размером). Требования - следствие устройства аппаратуры.","(лекция 13.11)"],
	["std::size_t ","(описан в <cstddef>) псевдоним беззнакового целого типа, достаточного для представления любых объектов на архитектуре","(лекция 13.11)"],
	["неявный параметр-объект","нестатические (без static) функции-члены класса имеют дополнительный явно не указанный в их описании параметр - неявный (не указанный синтаксически) параметр-объект (implicit object parameter) - задающий объект, на котором вызывается функция\n\nЕго тип по умолчанию - леводопустимая ссылка на тип самого класса","(лекция 13.11)"],
	["observers and mutators","нестатические функции-члены класса делят на наблюдателей (observer) и модификаторов (mutator)\n\nНаблюдатели указывают квалификатор const после списка параметров функции, который этим применяется к базовому типу ссылки неявного параметра объекта\n\nТ. о. наблюдатели вызываются на значениях любой изменяемости, а мутаторы - только на иземняемых","double f() const {...}; // наблюдатель\n\ndouble f() {...} // мутатор\n\n(лекция 13.11)"],
	["ключевое слово this","может использоваться в теле нестатических функций-членов класса и является prvalue - адресом неявного параметра объекта","(лекция 13.11)"],
	["прямая ( direct ) инициализация","форма инициализатора - пара круглых () или фигурных {} скобок со списком значений через запятую\n - форма с круглыми скобками в описаниях может конфликтовать с конструкцией производного типа \"функция\", особенно для пустого списка параметров. Все \n неоднозначности трактуются в пользу функции.","(лекция 20.11)"],
	["конструкторы","члены класса в виде функций без возвращаемого значения (для целей использования return - void), вместо имени - имя самого класса (формально - нет имени). Позволяют инициализировать класс путем выполнения произвольного кода, зависящего от произвольного набора значений.\n \nКласс с конструкторами - уже не агрегат. При попытке создания происходит разрешение перегрузок конструкторов, аргументы из списка (при инициализации списком), один аргумент при инициализации из одного значения, ноль аргументов при инициализации по умолчанию или значения\n\nВ определении конструктора может быть список инициализаторов в форме прямой инициализации, имеющих приоритет над инициализаторами подобъектов по умолчанию","constexpr inline struct polar_t {} polar{}; //тип и объект-тэг\n\nstruct point {\n double x,y;\n \n\n point() : x{},y{} {} //прямая инициализация списком\n point(double x, double y): x(x),y(y) {}//поиск имен!\n point(polar_t,double r, double phi) //параметр-тэг без имени (чтобы нормально работала перегрузка)\n : x(r*std::cos(phi)),y(r*std::sin(phi)) {}\n}\n\n(лекция 20.11)"],
	["инкапсуляция ( incapsulation )","скрытие деталей реализации объекта. Запрет прямого доступа к представлению в памяти позволяет предоставить произвольный интерфейс, от него не зависящий и гарантирующий инварианты.","(лекция 20.11)"],
	["инвариант ( invariant )","свойство объекта, которое он сохраняет на протяжении всего своего существования\n\nИнварианты могут быть нарушены модификаторами временно в процессе их работы","(лекция 20.11)"],
	["уровни доступа к членам класса","все члены классов имеют один из уровней доступа\n - открытые (public) члены класса доступны отовсюду\n - закрытые (private) члены класса доступны только ему и его членам\n\nПроверка уровня доступа - последний этап поиска имен, если имя нашлось в классовой области видимости (уже после разрешения перегрузок!)\n\nОпределяются по ближайшему спецификатору доступа (access specifier) в виде private: или public:.\n - для классов, определяемых с ключом struct, public по умолчанию, для class - private\n\nСледует применять одинаковый уровень доступа для всех нестатических членов данных класса","(лекция 20.11)"],
	["акцессоры ( accessors )","нестатические функции-члены класса, через которые осуществляется доступ к членам данных классов с инкапсуляцией","(лекция 20.11)"],
	["утверждения времени выполнения","в <cassert> описана макрос - функция assert с одним логическим параметром\n - в отладочной конфигурации сборки она вычисляет свой аргумент и прерывает аварийно работу программы, если оно ложно. При этом выводится сообщение на стандартный поток вывода ошибок (обычно, \"Assertion failed: ...\"), содержащее имя файла исходного текста, номер строки и выражение, проверка которого оказалась неудачной. В оптимизированной сборке программы раскрывается в пустую последовательность токенов, устраняя проверку из программы (в зависимости от определенности макроса NDEBUG).","(лекция 20.11)"],
	["утверждения времени компиляции","требует константности выражения, вычисляет его на этапе компиляции и становится ошибкой (включая текст сообщения, если указан) при его ложности","static_assert(expression);\n\n(лекция 20.11)"],
	["преобразования классовых типов, предусловия и постусловия, ширина контракта","","(лекция 20.11 (часть 2))"],
	["делегирование конструкторов","можно указать имя самого класса на месте имени подобъекта в списке инициализаторов конструктора. Результат - вызов другой перегрузки конструктора от указанных аргументов, а затем выполнение тела данного. Делегирование должно быть единственным элементом в списке инициализации, допускается по цепочке (без рекурсий).","struct test {\n int a;\n test(int x) : a(2*x+1) { std::cout << \"test(x)\\n\"}\n test(int a, int b) : test(a+b) { std::cout << \"test(a,b)\\n\" }\n}\n\n(лекция 27.11)"],
	["статические члены класса","члены данных или функции, описанные в классовой области видимости со спецификатором static - опять в новом смысле, отличном от его применения в блоках и пространствах имен!\n\nКонцептуально статические члены классов относятся не к конкретным экземплярам объектов классового типа, а к самому классу в целом (или ко всем объектам сразу), используя класс как область видимости, аналогично пространству имен.\n\nСтатические члены данных доступны не только через операцию выборки, но и просто по квалифицированным именам, что и следует предпочесть.","(лекция 27.11)"],
	["статические члены данных класса","\nНЕ входят в представление класса, являются просто объектами со статическим временем хранения в классовой области видимости.\n\nИнициализируются как в пространствах имен. При использовании без инициализатора являются описаниями и требуют определений с квалифицированными именами в окружающей области видимости пространства имен.\n\nМогут сразу являться определениями если, inline. Для статических членов данных класса constexpr подразумевает inline.","(лекция 27.11)"],
	["статически функции-члены класса","\nНЕ имеют неявного параметра объекта\n\nМножество перегрузок функций в классовой области видимости допускает смесь статических / не статических функций, но не допускаются перегрузки, отличающиеся только по наличию / отсутствию static\n\nПри вызове с объектом для привязки к неявному параметру объекту (выборка, явная или неявная), статические функции его игнорируют. При вызове без, не статические устраняются из множества перегрузок","(лекция 27.11)"],
	["перегрузка операций","классы позволяют задать семантику операций над ними (кроме ., :: и ?:). Некоторые перегружать не следует (, , &&, ||). Следует действовать по принципу \"наименьшего сюрприза\": сохранять свойства встроенных в язык операций и применять перегрузку только там, где такое их обозначение традиционно для предметной области.\n\nПерегрузки операций - функции с именами вида operator@, где @ - знак операции, а операнды - параметры. Постфиксные инкремент / декремент для отличия от префиксных - бинарные, со вторым фиктивным операндом 0.\n\nМогут быть свободными функциями (кроме =, [] и () ) или нестатическими членами класса (первый операнд - неявный параметр объект, непригодно, если требуется определить не для вашего класса). Нельзя ввести новые операции, нельзя поменять приоритет и ассоциативность (бинарные логические теряют вычисление по короткой схеме). В остальном тип возвращаемого значения, его семантика и побочные эффекты - любые.\n\nДо C++20 никакой автоматизации нет: переопределив ==, следует переопределить != в противоположном смысле самостоятельно, переопределив + (сложение), следует переопределить +=, и т.д.","(лекция 27.11)"],
	["prvalue классового типа","имя типа с синтаксисом прямой инициализации - приведение типов в функциональном стиле: int{5}, rational(3, 7)\n\n- для не ссылочного объекта - prvalue указанного типа\n\n- как prvalue, задает способ инициализации объекта\n\nВ случае, когда классовое prvalue требуется в качестве операнда выражения, происходит материализация временного объекта (temporary materialization) - инициализация временного xvalue, который будет уничтожен в конце полного выражения, в котором создан.\n\nОперация выборки членов данных возвращает результат категории левого операнда (может быть xvalue).\n\nКлассовые prvalue различают изменяемость, которая переходит в тип материализованного объекта.","rational f() {\n return rational(3,7); //задает способ инициализации объекта-результата\n}\n\nvoid g() {\n rational x = f(); //задает способ инициализации x\n //итого: 0 копий\n rational(1,2).num() // . требует glvalue, материализация, после вызова num унчитожение\n}\n\n(лекция 27.11)"],
	["непрямая привязка ссылок","обычно ссылки привязываются к значениям той же категории, что и в их названии (леводопустимые - к леводопустимым), но леводопустимые на неизменяемые объекты вяжутся к чему угодно.\n - ссылка, соответствующая неявному параметру объекту - исключение, игнорирующее категорию значения\n\n- при привязке к леводопустимой ссылке на const, если невозможно привязать напрямую (тип совпадает с точностью до отсутствия квалификатора), осуществляется попытка непрямой (indirect) привязки: создать временный объект нужного типа инициализацией копированием из данного значения\n\n- если привязка удачна, временный объект будет уничтожен позднее, вместе с ссылкой","void g(const rational& f);\nvoid f() {\n const double& x = 5; //materialize temp double(5) and bind\n const rational& y = 7; //materialize temp rational and bind\n g(15); //materialize temp rational, bind, destroy on ;\n //...\n //destroy temporaries bound to references x and y\n}\n\n(лекция 27.11)"],
	["списки инициализации и функции","списки инициализации могут инициализировать параметры и возвращаемые значения функций\n\n- выглядит как прямая инициализация, но является копированием по формальным правилам (т. е. не использует явные преобразования)","void g(const rational& r);\n\nrational f() {\n g({1,2});\n return {3,4};\n}\n\n(лекция 27.11)"],
	["аргументо-зависимый поиск ( argument-dependent lookup ) ( ADL )","многие функции, логически входящие в интерфейс класса, являются свободными, а не членами. Чтобы их вызывать по обычным правилам поиска имен, если сам класс в другом пространстве имен относительно точки использования, нужно квалифицированное имя - не всегда удобно, или даже возможно (перегруженные операции, обобщенный код)\n\n- при вызове функции, поименованной не квалифицированно, применяется аргументо-зависимый поиск: помимо найденного не квалифицированным поиском имен, дополнительно просматриваются описания из ассоциированных классов и пространств имен, соответствующих базовым типам аргументов\n\nПример - вызов << для потоков ввода вывода работает, несмотря на его описание в std::, даже без using namespace.\n\nЕсли вредит, отключается скобками вокруг имени.","(лекция 27.11)"],
	["друзья классов ( friend )","свободным функциям, входящим в интерфейс класса, может быть нужен доступ к деталям реализации\n\n- можно вносить исключения в уровни доступа к членам класса, описывая в нем \"друзей\" (friend): функции и классы, не являющиеся членами данного, имеющими полный доступ\n\n- вводятся описаниями в данном классе со спецификатором friend. Уровень на описаниях друзей игнорируется, сами описания членами класса не становятся\n\n- Для функций допустимы определения: вводят их как свободные (!) функции, доступные только для ADL","(лекция 27.11)"],
	["трехстороннее сравнение","операция <=> возвращает отношение порядка между двумя значениями как значение одного из типов из <compare>: \n - std::strong_ordering::equal/less/greater - порядок с подстановкой\n - std::weak_ordering::equivalent/less/greater - порядок без подстановки\n - std::partial_ordering::equivalent/less/greater/unordered - частичный порядок без подстановки\n - есть неявные преобразования от сильных категорий в слабые\n - определены сравнения остальными 6 операциями данных значений с нулем для преобразования в двусторонние отношения\n\n- сравнимы арифметические типы (bool только с bool, остальные по обычным арифметическим преобразованиям, не включая сужающие за исключением из целого в плавающую точку), для целых типов - std::strong_ordering, для плавающей точки - std::weak_ordering. Перечислители одного перечисления сравнимы как значения нижележащего типа","(лекция 27.11)"],
	["первичные и вторичные операции","для первичных операций рассматриваются перегрузки с обратным порядком аргументов (reversed). При их выборе результат инвертируется\n\n- для вторичных операций рассматривается их переписывание (rewrite) через первичную операцию\n\n- обращенные и переписанные операции хуже нормальных в разрешении перегрузок\n\n- обращения позволяют вдвое сократить число перегрузок для смешанных сравнений между двумя разными типами\n\n- перепись позволяет из одной операции выразить все остальные\n\n- т. о. для класса достаточно реализации первичных операций, через которые выражаются все остальные","(лекция 27.11)"],
	["определения по умолчанию","определение в форме = default; вместо тела функции - определение по умолчанию и может применяться для некоторых функций, для которых существуют \"стандартные формы записи\"\n\n- стандартная форма для всех 7 операций сравнения - лексикографический порядок по всем членам данных класса. Для обычных сравнений - результат bool. Для трехстороннего сравнения - самая слабая из категорий сравнения членов. Определение по умолчанию трехстороннего сравнения также определяет по умолчанию и сравнение на равенство.","struct S {\n int a; double b; double c;\n std::partial_ordering operator<=>(const S& other) const = default;\n //Эквивалентно\n //std::partial_ordering operator<=>(const S& other) const {\n // if(std::strong_ordering order = a<=>other.a ; order!=0) return order;\n // if(std::partial_ordering order = b<=>other.b ; order!=0) return order;\n // return c<=>other.c;\n //}\n}\n\n(лекция 27.11)"],
	["локальные классы","классы, определенные в блочной области видимости\n\n- не имеют доступа к объектам с автоматическим временем хранения, видимым из них\n\n- не могут содержать статических членов\n\n- для содержащихся в них описаний определения в окружающей области видимости дать нельзя","(лекция 27.11)"],
	["вложенные классы","классы, описанные в классовой области видимости\n\n- описания в них, требующие отдельных определений в окружающей области видимости, даются в окружающих пространствах имен, но не классах\n\n- если только описаны в не локальном классе, могут быть определены с квалифицированным именем в окружающем пространстве имен","(лекция 27.11)"],
	["концепция ( concept )","набор требований к типу в виде\n - синтаксиса допустимых конструкций языка с использованием этого типа (обычно, выражений, включающих значения этого типа)\n - семантики этих конструкций\n - ограничений по ресурсоёмкости этих конструкций.\nПри их соблюдении говорят, что тип \"удовлетворяет концепции\" (\"satisfies concept\").\nКонцепция может ссылаться и тем самым включать требования других концепций без их повторения - в таком случае она их \"уточняет\" (\"refines\").\nДо C++20 концепции не имеют синтаксических проявлений в самом языке, а используется только в документации.","(лекция 04.12)"],
	["шаблон ( template )","форма описания, задающая общий вид семейства описаний функций, классов, псевдонимов типов или объектов\n\nДопустимы только в областях видимости пространств имен и классов.\n\nЯвляются описаниями или определениями по правилам сущностей, семейства которых представляют.\n\nСинтаксически является описанием одной из выше упомянутых сущностей, перед которой в форме template<...> перечислены параметры шаблона (в угловых скобках через запятую, форма аналогична параметрам функций, включая возможное отсутствие имени и аргументы по умолчанию).","(лекция 04.12)"],
	["виды параметров шаблонов","типовые (type template parameter)\n\"typename\" (\"class\") вместо имени типа, соответствуют основной идее обобщенного программирования - параметризации по типам\n\n- нетиповые (non-type template parameter)\nОбычное описание с типом (целочисленным, перечислением или ссылкой). Шаблоны параметризируются значениями (константами)\n\n- шаблонные (template template parameter)\nШаблоны оперируют другими шаблонами","(лекция 04.12)"],
	["инстанциация и специализации шаблонов","шаблон сущности сам по себе сущностью не является.\nИмея определение шаблона, в точке использования его имени определяются значения параметров шаблона (способ зависит от вида используемой сущности), которые подставляются в его определение.\nПроцесс подстановки значений параметров шаблона в него называется инстанциацией (instantiation), а результат - специализацией (specialization) этого шаблона.\nСпециализация шаблона сущности некоторого вида есть эта сущность, которая далее используется по обычным для нее правилам.","(лекция 04.12)"],
	["шаблоны функций и разрешение перегрузок","шаблоны функций могут использоваться наравне с обычными функциями - одно множество перегрузок может содержать произвольное число шаблонов и обычных функций в любой комбинации\nОпределение значений параметров шаблона осуществляется как часть разрешения перегрузок одним из трех способов по порядку:\n - явно указанные значения в списке аргументов шаблона\n - дедукция\n - значения по умолчанию\nОшибки, выявляемые на любом из этих этапов, не являются ошибками программы, а просто устраняют соответствующую перегрузку как не годную (Substitution Failure Is Not An Error - SFINAE), в том числе невозможность установить значения всех параметров","(лекция 04.12)"],
	["список аргументов шаблона","указывается после имени функции в угловых скобках\nДолжен содержать значения аргументов для шаблона по порядку: для типовых - имена типов, для нетиповых - константные выражения, для шаблонных - имена шаблонов, лишние значения не допускаются.\nСам факт его наличия (даже пустого) устраняет все перегрузки, не являющиеся шаблонами, как не годные.","(04.12)"],
	["дедукция ( deduction )","алгоритм определения значения параметров шаблона путем сопоставления типа аргумента из контекста использования шаблона функции форме типа параметра из описания шаблона\nЕсли тип параметра не является ссылкой, при выводе отбрасываются квалификаторы (отражая независимость этой копии от исходного значения). Если тип параметра - ссылка, квалификаторы аргумента не отбрасываются при выводе, а указанные в типе параметра должны в нем присутствовать.\nДедукция выполняется для всех вхождений одного параметра шаблона в описании функции, для всех вхождений результат должен быть идентичен, иначе возникает ошибка дедукции.\nСуществуют недедуцируемые контексты (non-deduced context) - формы параметров, не участвующие в дедукции - не позволяют определить значения параметров шаблона, но и не вносят ошибки.","(лекция 04.12)"],
	["значения параметров шаблонов по умолчанию","аналогичны аргументам параметров функций, используются, только если предыдущие два способа выяснения параметров шаблона не дали результата\nВ отличие от аргументов по умолчанию, могут ссылаться на предыдущие: \n template<typename T,typename U = T>\n void f();\nЗначения параметров шаблонов по умолчанию не являются входными сведениями о типе аргументов для дедукции.","(лекция 04.12)"],
	["внедренное имя класса","каждый класс содержит открытое описание самого себя под своим именем - внедренное имя класса (injected class name). В шаблонах классов они именуют текущую специализацию (current specialization), если не имеют списка аргументов шаблона, иначе указанную, т. е. являются именем шаблона в целом.","template<typename T>\nstruct S {\n bool operator==(const S& other) const;\n void f() {S<int> x; }\n};\n\n(лекция 11.12)"],
	["друзья классов и шаблоны","00:07:00","(лекция 11.12)"],
	["явная специализация шаблонов классов","явный вид специализации для конкретных значений параметров шаблона задается описанием явной специализации (explicit specialization) шаблона класса\nЭта конструкция допустима и для шаблонов функций, но для них предпочтительнее перегрузка обычной функцией.","template<typename T>\nstruct S {\n //общий вид для любого допустимого T\n};\n\ntemplate<>\nstruct S<int> {\n //специальная форма для S<int>\n};\n(лекция 11.12)"],
	["частичная специализация шаблонов классов","используется для задания более частных случаев, чем первичный (primary) шаблон, но не с полностью заданными параметрами.\nИспользуется, если дедукция их параметров успешна. Если успешны несколько, частичный порядок определяется синтезом эквивалентных шаблонов функций и выбором из них.","template<typename T, typename U, typename V>\nstruct S {\n //общий случай\n};\n\ntemplate<typename U, typename V>\nstruct S<int,U,V> {\n //int и два разных параметра (годная для одинаковых, но проигрывает следующей для них)\n};\n\ntemplate<typename W>\nstruct S<int,W,W> {\n //int и два одинаковых параметра\n};\n\n(лекция 11.12)"],
	["явная и неявная инстанциация шаблонов","обычно используется неявная инстанциация шаблонов: \n - при использовании шаблонов функций описания инстанциируются в начале разрешения перегрузок, если выбрана специализация шаблона, инстанциируется под его определение\n - при необходимости полноты шаблона класса инстанциируется его определение с определениями всех членов, кроме функций. Для них определения инстанциируются по факту использования\n\nМожно явно контролировать процесс инстанциации:\n - определение явной инстанциации (explicit instantiation definition) заставляет транслятор сгенерировать указанную специализацию (определение, включая все члены)\n - описание явной инстанциации подавляет неявную инстанциацию","//s.hpp\n#ifndef S_HPP\n#define S_HPP\n\ntemplate<typename T>\nclass S {\n /* ... */\n};\n\nextern template class S<int>; //говорит о том что не надо генерировать специализацию S<int> (оставить только описание, должна найтись по связанности)\n |\n#endif //из-за extern\n\n//s.cpp\n#include \"s.hpp\"\n\ntemplate class S<int>; //находится здесь\n\n(лекция 11.12)"],
	["автоматический вывод типов в описаниях ( auto )","в определениях объектов с инициализатором конкретного типа допускается в качестве спецификатора типа использовать ключевое слово auto. В таком случае тип сущности определяется исходя из типа инициализатора как при выводе дедукцией значения типового шаблона на месте auto, где тип параметра функции - конструкция типа из определения, а аргумент - инициализатор: \n\n auto x = 5; // для f(t) вызов f(5) дает T=int,\n // подставляя вместо auto получаем тип x - int.\n auto& y = x; // f(&T) вызов f(x) дает T=int,\n // подставляя вместо auto получаем тип y - int&\n\nМожет быть в описаниях параметров функции, в таком случае это описание шаблона функции (даже если нет плашки template<...>), а каждому упоминанию auto соответствует свой безымянный типовой параметр шаблона, добавляемый к явно указанным в template<...> (если он был):\n\n void f(auto x);\n //эквивалентно\n template<typename _Unnamed1> void f(_Unnamed1 x);\n\n\n template<typename T> void g(T& x, auto& y, auto& z);\n //эквивалентно\n template<typename T, typename _Unnamed1, typename _Unnamed2>\n void g(T& x, _Unnamed1 y, _Unnamed2 z);","(лекция 15.01)"],
	["массив","конструкция создания производного типа на базе типа объекта, соответствующая последовательности таких объектов в памяти, расположенных непосредственно друг за другом. Их число - дополнительная характеристика, указываемая в конструкции. Синтаксис постфиксный, [N], где N - число элементов, константное целочисленное выражение >0, приводимое к size_t.\n\nМассивы, даже из изменяемых элементов, не являются модифицируемыми значениями.\n\nМассивы - агрегаты и могут быть инициализированы списками. Порядок элементов соответствует порядку в памяти.\n\nПреобразование \"разложение массива в указатель\" (array-to-pointer conversion) позволяет преобразовать glvalue типа T[N] в prvalue типа T* с адресом начального элемента массива.","void f() {\n int x[10] = {1,2,3}; //1,2,3,0,0,0,0,0,0,0\n *x = 10; //lvalue int[10] неявно в prvalue int* (адрес начального),\n //разыменованием в lvalue int (начальный элемент) \n}\n\n(лекция 15.01)"],
	["арифметика указателей","T* +/- integral -> T*: переход между элементами одного массива. Можно формировать указатель на послеконечный элемент, которого фактически нет (но нельзя разыменовывать). Другой выход за границы массива - UB.\n\nT* - T* -> std::ptrdiff_t - знаковое расстояние между элементами одного массива в элементах.\n\na[b] эквивалентно *(a+b)","(лекция 15.01)"],
	["массивы и функции","массивы никогда фактически не являются параметрами функций и числовыми значениями\n\nВозвращаемы значения-массивы запрещены.\n\nПараметры-массивы записывать, формально, можно, но действительный тип такого параметра - указатель на базовый тип, аналогично смене типов в array-to-pointer conversion. Запись рекомендуется для указания того, что этот, фактически, указатель - указатель на последовательность объектов, а не один.","void zero(int x[], std::size_t n);\n//эквивалентно\nvoid zero(int *x, std::size_t n);\n\n(лекция 15.01)"],
	["строковые литералы","строковые литералы имеют тип \"массив из неизменяемых char с числом элементов на один больше числа символов в литерале\" - в конце добавляется символ к кодом 0 - \"нуль-терминатор\"\n\nХранение строк в виде нуль-терминированных строк позволяет передавать строки в виде одного значения - указателя на начало (но поиск длины строки требует сканирования). Это представление пришло из C на уровне языка в виде литералов и поддержки стандартной библиотеки (и не единственно в C++).\n\nЗначения этих литералов - lvalue, соответствующие объектам со статическим временем хранения. Их адреса, в качестве исключения, могут быть не уникальны.","(лекция 15.01)"],
	["цикл for для диапазона","for(определение-одной-сущности-без-инициализатора-и-точки-с-запятой : выражение) оператор\n\nэквивалентно\n\n{\n auto expr = выражение;\n auto begin = std::begin(expr); //аналоги библиотечных функций, их не требующие\n auto end = std::end(expr);\n for (;begin!=end;++begin) {\n определение = *begin;\n оператор\n }\n}\n\nТаким образом позволяет перечислять значения массивов, std::array и прочих типов с begin/end. Небольшие элементы можно получать копиями, большие и для изменения по ссылке: \n\n int x[10] = {...};\n for (int e : x) std::cout << e << '\\n';\n std::span<BigClass> s = ...;\n for(BigClass &bc : s) bc.modify();","(лекция 15.01)"],
	["span","указание на интервал последовательно расположенных в памяти объектов. Хранится как указатель на начало + (возможно) длина, сам память под объекты не выделяет. Достаточно прост для передачи по значению без ссылок.\n\nДля доступа к элементам есть operator[]/size/empty, begin/end, аналогично std::array.\n\nДля выделения подинтервалов есть first/last/subspan. Версии с параметром функции возвращают динамические подspan'ы, версии с нетиповым параметром шаблона - статические.\n\nconstexpr std::size_t dynamic_extent = std::size_t(-1);\ntemplate<typename T,std::size_t N = dynamic_extent>\nclass span;\n\nT - тип элемента. Отражает в нем неизменяемость: span<int> преобразуется в span<const int> неявно, но не наоборот.\n\nN - число элементов, dynamic_extent если не задано, что означает что span \"динамического размера\", не известного на этапе трансляции. Спаны указанного в типе статического размера неявно приводимы к динамическим всегда, наоборот тоже, но UB, если размер не совпадает, между разными статического размера преобразований нет.\n\nSpan очень похож на std::array, однако span предназначен не для создания последовательности объектов в памяти, а для идентифицирования кем-то еще созданной такой последовательности или какой-то ее подпоследовательности. То есть уничтожив array мы теряем все объекты в нем находившееся, уничтожив span мы никакие элементы не трогаем, так как span это просто указатель + (возможно) длина, хранящаяся в памяти.","(лекция 22.01)"],
	["параметры программы","одним из предлагаемых вариантов описания функции main является int main(int argc, char* argv[]);\nгде argc - число элементов в массиве argv, минимум 1, каждый из которых - указатель на нуль-терминированную строку.\nПервый - имя программы с точки зрения вызывающей стороны, остальные - параметры программы, переданные ей вызывающей стороной, например, указанные после имени при запуске из оболочки.","(лекция 22.01)"],
	["динамическое время хранения","объекты с динамическим временем хранения создаются как побочный эффект вычисления операции new тип иницилизатор-не-копированием(опц)\nРезультат - адрес созданного объекта.\n\nОбъекты с таким временем существуют до применения к их адресу операции delete адрес-объекта-с-динамическим-временем-хранения\nРезультат операции - void.\ndelete для нулевых указателей корректен и не делает ничего.","(лекция 29.01)"],
	["динамическая память и массивы","когда тип в операции new имеет категорию массив, формально используется отдельная - векторная - форма операции new, в которой указывается базовый тип элемента и их количество в квадратных скобках, которые могут не быть константным выражением, и могут быть нулем. Результат - адрес нулевого из последовательности созданных и инициализированных объектов в памяти.\n\nПоследовательности, созданные векторной формой new, должны освобождаться векторной формой операции delete с парой квадратных скобок между ключевым словом и выражением.\n\nЕсли то, что выделено скалярно, освобождается не скалярно (аналогично с векторным) - undefined behaviour.","(лекция 29.01)"],
	["владение ( ownership )","ответственность за освобождение запрошенного ресурса, предоставленного в пользование.\n\nДинамическая память - один из наиболее часто встречаемых видов ресурсов.\n\nВладеть ресурсом (отвечать за освобождение) могут различные элементы программы: алгоритмы и их части ( функции ), структуры данных (объекты) и др.\n\nВ процессе работы программы эта ответственность может переходить от одного элемента программы к другому, что является передачей владения (ownership transfer).\n\nЧтобы освободить ресурс, нужно иметь возможность его идентифицировать. Объекты, хранящие значение, идентифицирующие ресурсы с целью их последующего освобождения, называют владеющими. После использования значения владеющего объекта для освобождения ресурса, он перестает быть владеющим. Невыполнение обязанности по освобождению ресурса (уничтожение владеющего объекта, замена его значения и др.) - логическая ошибка, называемая утечкой (leak) ресурсов.\n\nВладеющие указатели (owning pointer) хранят адреса, полученные в результате вычисления new. Остальные являются не владеющими (non-owning).","(лекция 05.02)"],
	["специальные функции члены класса","\nконструкторы по умолчанию,\nконструкторы перемещения,\nконструкторы копирования,\nоперации присваивания перемещением,\nоперации присваивания копированием и\n(потенциальные) деструкторы -\nспециальные функции-члены класса (special member functions)\n\nИсторически, единственные функции, для которых имелась стандартная форма, которая может быть запрошена определением по умолчанию (до сравнений C++20)\n\nСтандартная форма при некоторых условиях может быть определена компилятором даже без запроса программиста, если выполнены соответствующие условия и данная функция используется программой. \n\nКак и для прочих функций со стандартной формой, если она запрошена явно или сгенерирована неявно, но формально не корректна, определение превращается в удаленное.\n\n\n Степень вмешательства программиста в специальные функции\n\nФункции называют описанными пользователем (user-declared), если для них есть определение (любое, описанные, но не определенные функции нарушали бы ODR).\n\nФункции, предоставленные пользователем (user-provided) - определенные пользователем с явным телом, т. е. не в форме = default или = delete.\n\nНе предоставленные пользователем специальные функции-члены класса при выполнении дополнительных условий становятся тривиальными (trivial) - самыми \"простыми\" реализациями. Данные свойства полезны в оптимизациях компилятором и могут быть запрошены алгоритмами через метафункции семейства is_trivially_*. Свойства аналогичных операций распространяют и на не классовые типы: массивы, сохраняют свойства элемента, все остальные типы тривиальные по всем характеристикам.","(лекция 05.02)"],
	["конструктор по умолчанию","(default constructor) - конструктор, который можно вызвать без аргументов (параметров нет, или у всех значения по умолчанию)\n\nСтандартная форма определения - пустой список параметров, пустой список инициализаторов конструктора, пустое тело. Не является explicit, является constexpr, если форма по умолчанию удовлетворяет требованиям по вычислению константных выражений.\n\nОпределяется компилятором неявно, если в классе нет описанных пользователем конструкторов.\n\nКласс тривиально конструируем по умолчанию, если для его создания не требуется машинного кода: инициализация всех подобъектов сама по себе тривиальна для классов, а при сведении до не классовых подобъектов является инициализацией по умолчанию. Т. о. форма T() = default; предпочтительнее T() {}, поскольку сохраняет тривиальность.\n\nВсе остальные специальные функции связаны с понятием владения.","(лекция 05.02)"],
	["деструктор ( destructor )","(потенциальный) деструктор - специальная функция-член класса, отвечающая за уничтожение объектов класса.\n\nНе имеет имени, на его месте в описании указывается ~ИмяКласса, тип возвращаемого значения не указывается, фактически - void.\n\nНеявно описывается компилятором всегда, если не описан явно.\n\nВызывается всегда автоматически перед завершением времени хранения объекта, независимо от его вида (автоматическое - при выходе из блока, статическое - в результате вызова std::exit, динамическое - как побочный эффект delete).\n\nПосле выполнения тела деструктора подобъекты класса уничтожаются в порядке, обратном порядку создания, для классов это вызывает их деструкторы.\n\nТривиальный деструктор - деструктор, не требующий машинного кода, т. е. рекурсивно сводящийся к уничтожению не-классовых подобъектов.\n\nПары конструктор-деструктор выполняются всегда симметрично - если конструктор успешно отработал, будет вызван деструктор (в корректной программе без утечек памяти)\n\nТаким образом, совершая выделение ресурсов в конструкторе, а освобождение - в деструкторе гарантируется удовлетворение владения (автоматическое).","(лекция 05.02)"],
	["конструктор копирования","конструктор, принимающий левую ссылку на объект класса (любой cv-квалификации) и произвольное число параметров со значениями по умолчанию, не являющийся специализацией шаблона. \n\nКаноническая форма принимает одну ссылку на неизменяемый объект класса, поскольку обычно создание копии объекта не затрагивает оригинал. Другие или множественные формы конструкторов копирования обычно не применяются.\n\nВид определения по умолчанию - инициализация всех подобъектов из соответствующих подобъектов исходного, пустое тело. Не explicit, constexpr если написанная форма удовлетворяет соответствующим требованиям. Один параметр типа const T&, если у всех подобъектов есть конструкторы копирования из неизменяемых исходных, иначе T&.\n\nКласс тривиально копируем, если его копирование есть копирование представления, т. е. стандартная форма описания сводится к почленной инициализации подобъектов друг из друга, сводя до не классовых типов.\n\nВ примере RAII как раз обнаруживается, что классы, владеющие ресурсами, перестают по смыслу быть тривиально копируемыми и требуют задание явной правильной формы конструктора копирования."," (лекция 05.02)"]	
];